Using SecureString to put a password in an httpRequestMessage Header
So we're using a secure string when handling the password which will be used as part of the credentials to access a rest service. When I'm creating the HttpRequestMessage, I need to apply those credentials by entering them into the message header. In all of the examples I've seen for setting the credentials in the message header we need to convert the string to a base64 string before we applying it. Doesn't that defeat the purpose of having used a secure string everywhere else? IE we're going to have a base64 string dangling around in memory available to anyone who takes a dump of the process before GC kicks in? How can I avoid that? Here is what the code currently looks like:   IntPtr valuePtr = IntPtr.Zero; try { valuePtr = Marshal.SecureStringToGlobalAllocUnicode(credentials.Password); string password = Marshal.PtrToStringUni(valuePtr); //Also does the following concatenation also cause a string to be floating around after FreeGlobalAlloc is called? string computedAuthToken = $"{username}:{password}"; var message = new HttpRequestMessage(); var encoding = new ASCIIEncoding(); message.Headers.Add("Basic", Convert.ToBase64String(encoding.GetBytes(computedAuthToken))); //send async request and process response } finally { Marshal.ZeroFreeGlobalAllocUnicode(valuePtr); }  Also someone mentioned that we should "pin" the string otherwise it's possible for the GC to shuffle it around in memory and create additional copies of it sitting around in memory. Does Marshal.SecureStringToGlobalAllocUnicode ensure that it's pinned or do I need to do something extra like:  GCHandle handle = GCHandle.Alloc(password, GCHandleType.Pinned);   submitted by /u/MacrosInHisSleep [link] [comments] 