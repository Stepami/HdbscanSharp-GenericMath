Help with creating a neural network
I am trying to create a Convolutional neural net for image camera identification. Is there any existing code that i can use for my model? Here's the code that I have now.  import theano from theano import tensor as T import numpy as np from load import loader from load import lazy_load import lasagne from lasagne.nonlinearities import leaky_rectify, softmax from lasagne import layers from lasagne.init import Orthogonal def iter_minibatch (inputs, targets, batchsize, shuffle=False): for i in range(0, len(inputs), batchsize): yield inputs[i:batchsize], targets[i, batchsize] input_var = T.tensor4 ('X') target_var = T.vector ('Y') print "starting" #Model network = layers.InputLayer ((None, 3, 300, 300), input_var) network = layers.Conv2DLayer (network, 64, (5,5), nonlinearity=leaky_rectify) network = layers.Conv2DLayer (network, 32, (5,5), nonlinearity=leaky_rectify) network = layers.Pool2DLayer (network, (5,5), stride=2, mode='max') network = lasagne.layers.DenseLayer(lasagne.layers.dropout (network, 0.5), 128, nonlinearity=leaky_rectify, W=Orthogonal()) network = lasagne.layers.DenseLayer(lasagne.layers.dropout (network, 0.5), 10, nonlinearity=softmax) print "done" prediction = lasagne.layers.get_output(network) loss = lasagne.objectives.categorical_crossentropy(prediction, target_var) loss = loss.mean() + 1e-4 * lasagne.regularization.regularize_network_params( network, lasagne.regularization.l2) params = lasagne.layers.get_all_params(network, trainable=True) updates = lasagne.updates.nesterov_momentum(loss, params, learning_rate=0.01, momentum=0.9) # compile training function that updates parameters and returns training loss train_fn = theano.function([input_var, target_var], loss, updates=updates) trX = [] trY = [] train_data, test_data, valid_data = loader (0.1, 0.2, 0.2) for val in train_data[0]: trX.append (lazy_load (val)[0]) trY.append (val[1]) # train network (assuming you've got some training data in numpy arrays) for epoch in range(100): loss = 0 for inputs, targets in iter_minibatch (trX, trY, 50, False): loss += train_fn (inputs, targets) print("Epoch %d: Loss %g" % (epoch + 1, loss / len(trX))) # use trained network for predictions test_prediction = lasagne.layers.get_output(network, deterministic=True) predict_fn = theano.function([input_var], T.argmax(test_prediction, axis=1)) print("Predicted class for first test input: %r" % predict_fn(test_data[0]))  I am constantly getting  TypeError: integer vector required for argument: true_one_of_n(got type: TensorType(float32, vector) instead of: TensorType(int64, vector))  What am I doing wrong here? Also, Should trY be a vector of 10 integers rather than a integer with value n where n is between 0 - 10 representing the classes?  submitted by /u/bheemboy69 [link] [comments] 