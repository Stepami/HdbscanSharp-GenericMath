Creating a nullable ComboBox for WPF
I am trying to create a reusable control for WPF which allows the user to select a null option in addition to all the items in the ItemsSource binding. In addition, I want to be able to have a dependency property on the control which sets the text to display for the null option. For example, if the ComboBox was being used to filter a list, I might want the null option to be displayed as "All" in the list. As a starting point, I converted the code from this blog post into C#. The xaml look like this:                As you can see, I added a DataTemplate to the resources of the ComboBox which applies to the null placeholder object and sets the text to the specified NullPlaceHolder text. The code behind looks like this:  using System.Collections; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Windows; using System.Windows.Controls; namespace MyApp.Views { ///  /// Interaction logic for NullableComboBox.xaml ///   public partial class NullableComboBox : UserControl { NullPlaceholder placeholder; public NullableComboBox() { InitializeComponent(); placeholder = new NullPlaceholder() { DisplayString = NullDisplayText }; } #region NullDisplayText public string NullDisplayText { get { return (string)GetValue(NullDisplayTextProperty); } set { SetValue(NullDisplayTextProperty, value); placeholder.DisplayString = value; } } public static readonly DependencyProperty NullDisplayTextProperty = DependencyProperty.Register("NullDisplayText", typeof(string), typeof(NullableComboBox), new FrameworkPropertyMetadata(string.Empty, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, OnDependencyPropertyChanged)); #endregion #region "SelectedItem and ItemsSource" ///  /// Pretty much just a simple wrapper around ComboBox.SelectedItem , but on /// the underlying ComboBox  Nothing  is replaced by the singleton /// instance of NullPlaceholder . ///   public object SelectedItem { get { return GetValue(SelectedItemProperty); } set { SetValue(SelectedItemProperty, value); if (value == null) { combo.SelectedItem = placeholder; } else { combo.SelectedItem = value; } } } public static readonly DependencyProperty SelectedItemProperty = DependencyProperty.Register("SelectedItem", typeof(object), typeof(NullableComboBox), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, OnDependencyPropertyChanged)); ///  /// Wraps ComboBox.ItemsSource , but adds the singleton instance of /// ComboBox.SelectedItem  to the list. ///   public IEnumerable ItemsSource { get { return (IEnumerable)GetValue(ItemsSourceProperty); } set { SetValue(ItemsSourceProperty, value); // Set the items source for the actual combo box List listWithNull = new List(); listWithNull.Add(placeholder); foreach (var element in value) { listWithNull.Add(element); } combo.ItemsSource = listWithNull; SelectedItem = null; } } public static readonly DependencyProperty ItemsSourceProperty = DependencyProperty.Register("ItemsSource", typeof(IEnumerable), typeof(NullableComboBox), new FrameworkPropertyMetadata(null, OnDependencyPropertyChanged)); private static void OnDependencyPropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args) { dynamic self = (NullableComboBox)obj; if (object.ReferenceEquals(args.Property, SelectedItemProperty)) { self.SelectedItem = args.NewValue; } else if (object.ReferenceEquals(args.Property, ItemsSourceProperty)) { self.ItemsSource = (IEnumerable)args.NewValue; } else if (object.ReferenceEquals(args.Property, NullDisplayTextProperty)) { self.placeholder.DisplayString = args.NewValue.ToString(); } } private void combo_SelectionChanged(object sender, SelectionChangedEventArgs e) { // The property the is bound to NullableComboBox.SelectedItem needs to be set to Nothing when the // null option is chosen, not NullPlaceholder.Instance, so convert it here if necessary if (combo.SelectedItem is NullPlaceholder) { SelectedItem = null; } else { SelectedItem = combo.SelectedItem; } } #endregion #region "Uninteresting ComboBox wrapper properties" // Cut for brevity #endregion } #region "NullPlaceholder class" public class NullPlaceholder { public string DisplayString { get; set; } ///  /// This is here so that if you don't define a a DataTemplate  for this type /// you will see a blank option instead of "NullableComboBox+NullPlaceholder". ///   public override string ToString() { return DisplayString; } } #endregion  As defined, this works as intended as long as DisplayMemberPath on the NullableComboBox is not set. If it is set, however, the NullPlaceholder object is displayed as just a blank space rather than with the DataTemplate specified in the resources. From what I understand, this is because setting the DisplayMemberPath causes the DataTemplate to be overridden with a TextBlock whose Text is bound to the Path specified by DisplayMemberPath. Since that property is not defined in the NullPlaceholder, the result is a blank TextBlock. Is there a way to get this to work in conjunction with DisplayMemberPath? One thought I had was to use an ItemTemplateSelector for the ComboBox. The selector would choose between two templates, one for the NullPlaceholder and one for any other item in the ComboBox. The issue I couldn't get around is how to use the DisplayMemberPath within this second template to display the non-null options properly. Is there another approach I can take? Thanks for the help!  submitted by /u/ahage16 [link] [comments] 