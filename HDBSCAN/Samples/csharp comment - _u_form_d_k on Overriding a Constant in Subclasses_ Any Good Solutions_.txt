/u/form_d_k on Overriding a Constant in Subclasses: Any Good Solutions?
Wow. That's a lot of useful information. :) I appreciate the help! I wasn't familiar with System.ComponentModel.Composition and it's something I need to consider using. I have a strong suspicion I re-implemented some of what's there. :*(   I'm not a software engineer, but a programmer writer (I read tons of code & usually write small tutorials or simple internal tools). I'm not ever sure if I'm doing things the "right way" and very rarely am given the luxury of a code review.   I've been ripping things apart & refactoring, so the codebase is a bit of a mess right now. This is roughly what I intended for final implementation. I don't know how "bad" the code is; other than me you're the first to see it. :P   RecordStream.cs     // Needs refactoring. public async Task StreamRecordsAsync() { // This is to support concurrent async streams. MemoryStream memoryStream = new MemoryStream(StreamedBytes); int signatureLength = Record.SignatureLength; int byteSizeOfSignature = Record.SignatureLength * sizeof(char); byte[] signatureBuffer = new byte[byteSizeOfSignature]; using (memoryStream) { while ((memoryStream.EndOfStream != true) && ((memoryStream.Length - memoryStream.Position) % byteSizeOfSignature == 0)) { memoryStream.ReadBlock(signatureBuffer, 0, byteSizeOfSignature); string signature = new string(DataFormat.Encoding.GetString(signatureBuffer).ToCharArray()); if (Regex.IsMatch(signature, Record.SignaturePattern)) { if (DataFormatHandler.IsSupportedSignature(signature)) { Type recordType = DataFormat.RecordTypes[signature]; RecordTypeInfo recordInfo = DataFormat.RecordTypeInfos[recordType]; if (recordInfo == null) { // This will only happen once per unique signature. recordInfo = DataFormat.ReflectOnRecord(recordType); } HeaderTypeInfo headerInfo = recordInfo.HeaderInfo; // Among the hundreds of record types // there are at least 3 kinds of record headers, // each with a set length. int headerLength = headerInfo.Length; byte[] headerBuffer = new byte[headerLength]; await memoryStream.ReadAsync(headerBuffer, 0, headerLength); dynamic recordHeader = RecordHeader.Construct(headerInfo, headerBuffer); // We need to know the length of field data bytes to pull out of the stream. // This usually is specified in the header's first int32 field. // But in one seldomly used header, the field defines the header length // PLUS data fields length. int fieldsLength= recordHeader.DataLength - headerInfo.Offset; byte[] fieldsBuffer = new byte[fieldsLength]; await memoryStream.ReadAsync(fieldsBuffer, 0, fieldsLength); dynamic record = Record.Construct(recordInfo, recordHeader, fieldBuffer); Records.Add(record); } else { // For records not supported natively: Records.Add(Record.Construct(signature, memoryStream)); } } } } }     And here is where a record gets instantiated: Record.cs     public static object Construct(RecordTypeInfo recordInfo, RecordHeader recordHeader, byte[] fieldBytes) { object[] parameters = new object[] { recordInfo, recordHeader, fieldBytes }; dynamic record = recordInfo.Constructor.Invoke(parameters); return record; } // And in the base constructor: internal Record(RecordHeader header, byte[] fields) { Header = header; List chunks = DivideFields(fields); // List // Chunks will either be binary data converted & assigned to a member // OR preceded by a signature denoting the chunk is a // subrecord (a subrecord header followed by a collection of fields and/or subrecords). // // Unlike top-level records, subrecord signatures are not unique // (i.e. a WXYZ subrecord, depending on parent record, // could be an int, string, or a complex subrecord. // // This means subrecords should be streamed like other subrecords, // but their RecordInfo property must be obtained from their parent's // List FieldInfos property in the RecordTypeInfo property. AssignFields(); }       My original question about constants was from me wanting to easily give type information to users (i.e. SuperSimpleRecord.Signature, SuperSimpleRecord.Info, etc.) and me not being able to enforce implementation of those properties.   