/u/WeRequireCoffee on Variables not being set?
Here's a few examples:   ///  /// Dont do this, but an example of alternative code ///   static void ExtractFlowBad() { List tempDescendingList = new List(); List tempAscendingList = new List(); for (int i = 0; i < numbers.Length; i++) { try { if (numbers[i] > numbers[i - 1]) { tempAscendingList.Add(numbers[i]); Console.WriteLine($"Added {numbers[i]} to ascending"); } else if(numbers[i] < numbers[i - 1]) { tempDescendingList.Add(numbers[i]); Console.WriteLine($"Added {numbers[i]} to descending"); } // still doesnt deal with that pesky equivalent operator! } catch { tempAscendingList.Add(numbers[i]); Console.WriteLine($"Added {numbers[i]} to ascending"); } // deliberately writing code that will throw exceptions like this has a computational cost to be aware of. // Do not write production code like this. // Throwing exceptions is fine but throwing them to avoid logic is bad behavior } double descendingAverage = ((double)tempDescendingList.Count / (tempAscendingList.Count + tempDescendingList.Count)); double ascendingAverage = ((double)tempAscendingList.Count / (tempAscendingList.Count + tempDescendingList.Count)); Console.WriteLine($"Ascending average: {ascendingAverage.ToString("P")}"); Console.WriteLine($"Descending average: {descendingAverage.ToString("P")}"); } ///  /// Better designed but if you wanted to it can still be cleaned up. This would be a good 'stopping' point imho ///   static void ExtractFlowMovingOnUp() { var tempDescendingList = new List(); var tempAscendingList = new List(); var tempEquivalentList = new List(); for (int i = 0; i < numbers.Length; i++) { // The i == 0 short circuits the right hand side of the expression before it can throw an exception // Note that the || operator short circuits while the | doesnt. There are very few instances where the // | operator is advisable over the || and can be a serious headache for locating bugs if (i == 0 || numbers[i] > numbers[i - 1]) { tempAscendingList.Add(numbers[i]); // by using the nameof operator to reference the variable, in the event that you decide to change the name of it // the debug calls reference the correctly updated name now without you having to manually update all instances of it Debug.WriteLine($"Added {numbers[i]} to {nameof(tempAscendingList)}"); } else if (numbers[i] < numbers[i - 1]) { tempDescendingList.Add(numbers[i]); Debug.WriteLine($"Added {numbers[i]} to {nameof(tempDescendingList)}"); } else { tempEquivalentList.Add(numbers[i]); Debug.WriteLine($"Added {numbers[i]} to {nameof(tempEquivalentList)}"); } } var descendingPercent = (double)tempDescendingList.Count / (numbers.Count()); var ascendingPercent = (double)tempAscendingList.Count / (numbers.Count()); var equivalentPercent = (double)tempEquivalentList.Count / (numbers.Count()); Console.WriteLine($"Ascending Percent: {ascendingPercent.ToString("P")}"); Console.WriteLine($"Descending Percent: {descendingPercent.ToString("P")}"); Console.WriteLine($"Equivalent Percent: {equivalentPercent.ToString("P")}"); } ///  /// This is a 'cute' method ///   static void ExtractFlowProbablyTooFar() { var movementDictionaries = new Dictionary>(); movementDictionaries.Add("Descending", new List()); movementDictionaries.Add("Equivalent", new List()); movementDictionaries.Add("Ascending", new List()); for (int i = 0; i < numbers.Length; i++) { var index = i == 0 ? 2 : numbers[i].CompareTo(numbers[i - 1]) + 1; movementDictionaries.ElementAt(index).Value.Add(numbers[i]); Debug.WriteLine($"Added {numbers[i]} to {movementDictionaries.ElementAt(index).Key}"); } foreach (var movDict in movementDictionaries) Console.WriteLine($"{movDict.Key} Percent: {((double)movDict.Value.Count / numbers.Count()).ToString("P")}"); }               