/u/alien_at_work on How exactly are multiple running processes managed on a single core, on an architectural level?
But how does the time slice end? Your code doesn't necessarily switch back to the kernel intentionally, but it will get stopped anyway.  It should probably be pointed out that there are two ways a process stops: it runs out of time via the method you described or it "voluntarily" gives up the CPU by making a "system call" (i.e. anything the Operating System must do like e.g. opening a file). For a modern scheduling system, processes that use up their whole time will get "penalized" (effectively: scheduled less often, but possibly with longer time quantums) and those that quickly give up CPU are given higher priority. This is how your computer can still have a responsive GUI even with things like compilers running in the background: because the GUI is always giving up the CPU very quickly so it's always very high priority.   