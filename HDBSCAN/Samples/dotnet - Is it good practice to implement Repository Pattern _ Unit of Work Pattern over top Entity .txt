Is it good practice to implement Repository Pattern / Unit of Work Pattern over top Entity Core
This section of text comes from Microsoft docs. The Entity Framework is it itself an implementation of Unit of Work and Repository Patterns. Is it common to implement another UOW / Repository pattern over Entity? I see a lot of tutorials and articles that do so and wondering what best practices are being used for real world applications. Many developers write code to implement the repository and unit of work patterns as a wrapper around code that works with the Entity Framework. These patterns are intended to create an abstraction layer between the data access layer and the business logic layer of an application. Implementing these patterns can help insulate your application from changes in the data store and can facilitate automated unit testing or test-driven development (TDD). However, writing additional code to implement these patterns is not always the best choice for applications that use EF, for several reasons: The EF context class itself insulates your code from data-store-specific code. The EF context class can act as a unit-of-work class for database updates that you do using EF. EF includes features for implementing TDD without writing repository code.  I suppose you could simply inject the DbContext in a service layer class and access the database like so.  public class ProjectService { private readonly SandstormDbContext _dbContext; public ProjectService(SandstormDbContext dbContext) { _dbContext = dbContext; } public List GetProjects() { return _dbContext.Projects.ToList(); } }   As opposed to Project Repository  public class ProjectRepository: IProjectRepository { private readonly SandstormDbContext _dbContext; public ProjectRepository(SandstormDbContext dbContext) { _dbContext = dbContext; } public IQueryable GetProjects() { return _dbContext.Projects; } }   And then  public class ProjectService { private readonly IProjectRepository _projectRepository; public ProjectService(IProjectRepository projectRepository) { _projectRepository = projectRepository; } public List GetProjects() { return _projectRepository.GetProjects().ToList(); } }   Transactions with Entity Framework seem odd to me coming from Java / Spring world were we just annotate method with @Transactional. If multiple collections are going to be operated a reference to DbContext would be needed to start a transaction, perhaps at controller level, which in some ways defeats purpose of Repository layer where you want to encapsulate the DbContext and not have it bleed through layers. I suppose from a DDD perspective the Repository patterns makes sense as you wouldn't want to expose direct access to some entities, Example Order and LineItem would only have a OrderRepository and no repository for LineItem.  submitted by /u/greyf0x55 [link] [comments] 