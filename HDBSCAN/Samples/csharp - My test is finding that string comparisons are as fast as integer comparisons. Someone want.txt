My test is finding that string comparisons are as fast as integer comparisons. Someone want to figure out what I'm doing wrong?
The tests are here:  class Program { private static string[] strComp = {"com.PeculiarHabit.FooTestR", "com.PeculiarHabit.Yerp", "com.PeculiarHabit.Bah", "com.PeculiarHabit.Meh","com.PeculiarHabit.Yar", "com.PeculiarHabit.Foo", "com.PeculiarHabit.FooTest", "com.PeculiarHabit.Yerp", "com.PeculiarHabit.Bah", "com.PeculiarHabit.Meh", "com.PeculiarHabit.Yar", "com.PeculiarHabit.Foo", "com.PeculiarHabit.FooTest", "com.PeculiarHabit.Yerp", "com.PeculiarHabit.Bah", "com.PeculiarHabit.Meh", "com.PeculiarHabit.Yar", "com.PeculiarHabit.Foo", "com.PeculiarHabit.FooTest", "com.PeculiarHabit.Yerp", "com.PeculiarHabit.Bah", "com.PeculiarHabit.Meh", "com.PeculiarHabit.Yar", "com.PeculiarHabit.Foo"}; private static int[] intComp = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}; private static readonly Random Rnd = new Random(); static void Main(string[] args) { Console.WriteLine(strComp.Length); Console.WriteLine(intComp.Length); Console.WriteLine(); RunTests(); RunTests(); RunTests(); RunTests(); RunTests(); RunTests(); RunTests(); RunTests(); Console.WriteLine("Press any key to continue..."); Console.ReadKey(true); } public static void RunTests() { var cycles = 100000000; var sw = new Stopwatch(); sw.Start(); var foo1 = Test1(cycles); sw.Stop(); Console.WriteLine($"Time: {sw.ElapsedTicks}"); foo1 = sw.ElapsedTicks; Console.WriteLine($"TicksPerCycle: {(double)foo1 / cycles}"); sw.Reset(); sw.Start(); var foo2 = Test2(cycles); sw.Stop(); Console.WriteLine($"Time: {sw.ElapsedTicks}"); foo2 = sw.ElapsedTicks; Console.WriteLine($"TicksPerCycle: {(double)foo2 / cycles}"); Console.WriteLine((double)foo2 / foo1); Console.WriteLine(); } public static long Test1(int testCount) { var ret = 0; for (var i = 0; i < testCount; i++) { var n = Rnd.Next(0, strComp.Length); if (strComp[n] == strComp[0]) ret++; } return ret; } public static bool FastCompare(string str1, string str2) { if (str1.Length != str2.Length) return false; return str1 == str2; } public static long Test2(int testCount) { var ret = 0; for (var i = 0; i < testCount; i++) { var n = Rnd.Next(0, intComp.Length); if (intComp[n] == intComp[0]) ret++; } return ret; } }  So basically, I'm making an eventing system, and was hoping to "decouple" everything by using string names instead of enumerations, or actual objects. I figured I'd run some tests to see how the string comparisons would "hurt" me, and to my great surprise, my tests are showing the comparisons to be the same speed. I use the random index to try and avoid any compiler optimizations, but other than that, there's nothing fancy happening here. On my box, I get that the difference between the two is non-existent (like in the less than 1% range). I suppose it's possible that under the hood the strings are only being compared by a reference to the pointer, but that's total spitballing on my part, as I have no idea what's going on. Any idea why this wouldn't show the expected slowdown from string comparisons? Edit: On a whim, I changed all of the strings to be the exact same length. Suddenly, all of the tests tanked, showing that comparing integers was about 20-30% faster. Under the hood, is the system comparing string length first as an optimization?  submitted by /u/Javin007 [link] [comments] 